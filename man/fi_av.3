.TH "FI_AV" 3 "2014-09-11" "libfabric" "Libfabric Programmer's Manual" libfabric
.SH NAME
fi_av \- Address vector operations
.PP
fi_av_open / fi_close
.RS
Open or close an address vector
.RE
.PP
fi_av_bind
.RS
Associate an address vector with an event queue.
.RE
.PP
fi_av_insert / fi_av_remove
.RS
Insert/remove an address into/from the address vector.
.RE
.PP
fi_av_lookup
.RS
Retrieve an address stored in the address vector.
.RE
.PP
fi_av_straddr
.RS
Convert an address into a printable string.
.RE
.SH SYNOPSIS
.B #include <rdma/fi_domain.h>
.HP
.BI "int fi_av_open(struct fid_domain *" domain ", struct fi_av_attr *" attr ", "
.BI "struct fid_av **" av ", void * " context ");"
.HP
.BI "int fi_close(struct fid *" av ");"
.PP
.HP
.BI "int fi_av_bind(struct fid_av *" av ", struct fid *" eq ", uint64_t " flags ");"
.PP
.HP
.BI "int fi_av_insert(struct fid_av *" av ", void *" addr ", size_t " count ", "
.BI "fi_addr_t *" fi_addr ", uint64_t " flags ");"
.HP
.BI "int fi_av_remove(struct fid_av *" av ", fi_addr_t " fi_addr ", size_t " count ", "
.BI "uint64_t " flags ");"
.HP
.BI "int fi_av_lookup(struct fid_av *" av ", fi_addr_t " fi_addr ", "
.BI "void *" addr ", size_t *" addrlen ");"
.HP
.BI "const char * fi_av_straddr(struct fid_av *" av ", const void *" addr ", "
.BI "void *" buf ", size_t " len ");"
.SH ARGUMENTS
.IP "domain"
Resource domain
.IP "av"
Address vector 
.IP "eq"
Event queue
.IP "attr"
Address vector attributes
.IP "context"
User specified context associated with the address vector.
.IP "addr"
Buffer containing one or more addresses to insert into address vector.
.IP "addrlen"
On input, specifies size of addr buffer.  On output, stores number of bytes
written to addr buffer.
.IP "fi_addr"
For insert, a reference to an array where returned fabric addresses
will be written.
.br
For remove, one or more fabric addresses to remove.
.IP "count"
Number of entries referenced by addr and/or fi_addr.
.IP "flags"
Additional flags to apply to the operation.
.SH "DESCRIPTION"
Address vectors are used to map higher level addresses, which may be
more natural for an application to use, into fabric specific addresses.
The mapping of addresses is fabric and provider specific, but may involve
lengthy address resolution and fabric management protocols.  AV operations
are synchronous by default, but may be set to operate asynchronously by
associating the AV with an event queue.
.SS "fi_av_open"
fi_av_open allocates or opens an address vector.  The properties and behavior of
the address vector are defined by struct fi_av_attr.
.PP
.nf
struct fi_av_attr {
	enum fi_av_type      type;      /* type of AV */
	size_t               count;     /* # entries for AV */
	const char          *name;      /* system name of AV */
	void                *map_addr;  /* base mmap address */
	uint64_t             flags;     /* operation flags */
};
.fi
.IP "type"
An AV type corresponds to a conceptual implementation of an address vector.
The type specifies how an application views data stored in the AV,
including how it may be accessed.  Valid values are:
.RS
.IP "FI_AV_MAP"
Addresses which are inserted into an AV are mapped to a native fabric
address for use by the application.  Mapped addresses are usable with
data transfer operations, such that costly translations or lookups can
be avoided.  Addresses are stored in the AV using a provider specific
mechanism, including, but not limited to a tree, hash table, or maintained
on the heap.  FI_AV_MAP is often used with address format FI_ADDR.
.IP "FI_AV_TABLE"
Addresses which are inserted into an AV are accessible using a simple
index.  Conceptually, the AV may be treated as an array of addresses,
though the provider may implement the AV using a variety of mechanisms.
FI_AV_TABLE is often used with address formats FI_AV and FI_ADDR_INDEX.
.RE
.IP "count"
Indicates the expected number of addresses that will be inserted into
the AV.  The provider uses this to optimize resource allocations.
.IP "name"
An optional system name associated with the address vector to create or open.
Address vectors may be shared across multiple processes which access
the same named domain on the same node.  The name field allows the
underlying provider to identify a shared AV.
.sp
If the name field is non-NULL and the AV is not opened for read-only
access, a named AV will be created, if it does not already exist.
.IP "map_addr"
The map_addr determines the base FI_ADDR address that a provider
should use when sharing an AV of type FI_AV_MAP between processes.
Processes that provide the same value for map_addr to a shared AV may
use the same FI_ADDR values returned from an fi_av_insert call.
.sp
The map_addr may be used by the provider to mmap memory allocated for a
shared AV between processes; however, the provider is not required to use
the map_addr in this fashion.  The only requirement is that an FI_ADDR
returned as part of an fi_av_insert call on one process is usable on
another process which opens an AV of the same name at the same map_addr
value.  The relationship between the map_addr and any returned FI_ADDR
is not defined.
.sp
If name is non-NULL and map_addr is 0, then the map_addr used by the
provider will be returned through the attribute structure.  The map_addr
field is ignored if name is NULL.
.IP "flags"
The following flags may be used when opening an AV.
.RS
.IP "FI_READ"
Opens an AV for read-only access.  An AV opened for read-only access
must be named (name attribute specified), and the AV must exist.
.RE
.SS "fi_close"
The fi_close call is used to release all resources associated with an
address vector.  Note that any events queued on an event queue referencing
the AV are left untouched.  It is recommended that callers retrieve all
events associated with the AV before closing it.
.SS "fi_av_bind"
Associates an event queue with the AV.  Binding an event queue to an
AV indicates that the provider should perform all insertions asynchronously,
with the completions reported through the event queue.  If an event queue
is not bound to the AV, then insertion requests behave synchronously.
.SS "fi_av_insert"
The fi_av_insert call inserts one or more addresses into an AV.  The number
of addresses is specified through the count parameter.  The addr parameter
references an array of addresses to insert into the AV.  Addresses
inserted into an address vector must be in the same format as specified
in struct fi_info:info_addr_format for the corresponding domain.  A NULL
value for an address may be used to indicate that an entry should be
associated with 'any' address (similar to the IPv4 address of 0.0.0.0).
.PP
For AV's of type FI_AV_MAP, once inserted addresses have been mapped,
the mapped values are written into the buffer referenced by fi_addr.
Addresses written to fi_addr use the format as specified in struct
fi_info:addr_format.  The fi_addr buffer must remain valid until the
AV insertion has completed and an event has been generated
to an associated event queue.
.PP
For AV's of type FI_AV_TABLE, addresses are placed into the table in
order.  That is, the first address inserted may be referenced at
index 0.  The fi_addr parameter may be NULL in this case.  Otherwise,
fi_addr must reference an array of fi_addr_t, and the buffer must
remain valid until the insertion operation completes.
.PP
The FI_RANGE flag may be used with fi_av_insert to indicate that a range
of addresses should be inserted.  See the flags discussion below.
.SS "fi_av_remove"
fi_av_remove removes a set of addresses from an address vector.  All
resources associated with the indicated addresses are released, and
no future references to either the mapped address (in the case of
FI_AV_MAP) or index (FI_AV_TABLE) are allowed.
.PP
The use of fi_av_remove is an optimization that applications may use
to free memory allocated with addresses that will no longer be accessed.
Inserted addresses are not required to be removed.  fi_av_close will
automatically cleanup any resources associated with addresses remaining
in the AV when it is invoked. 
.SS "fi_av_lookup"
This call returns the address stored in the address vector that corresponds
to the given fi_addr.  The returned address is the same format as those
stored by the AV.  On input, the addrlen parameter should
indicate the size of the addr buffer.  If the actual address is larger than
what can fit into the buffer, it will be truncated.  On output, addrlen
is set to the size of the buffer needed to store the address, which may
be larger than the input value.
.SS "fi_av_straddr"
The fi_av_straddr function converts the provided address into a printable
string.  The specified address must be of the same format as those
stored by the AV, though the address itself is not required to have been
inserted.  On input, the len parameter should specify the size of the buffer
referenced by buf.  On output, the actual size needed to write the entire
string will be returned.  This size may be larger than the input len.  If
the provided buffer is too small, the results will be truncated.  fi_av_straddr
returns a pointer to buf.
.SH "FLAGS"
The following flags are usable with fi_av_insert.
.IP "FI_RANGE"
FI_RANGE allows for multiple addresses to be inserted into an AV by
specifying only the starting and ending addresses, inclusive, for a
range of given addresses.  When multiple addresses are inserted into
the AV with FI_RANGE enabled, the provided addresses are processed in pairs.
Each pair indicates the first and last address of a range of addresses that
the AV should store.  If an odd number of addresses are inserted into
the AV, the final address is treated as a single address.
.sp
When FI_RANGE is in use, the AV will return one mapped address for
every address that is inserted, including those address specified
indirectly as part of a given range.
.SH "NOTES"
Providers may implement AV's using a variety of mechanisms.  Specifically,
a provider may begin resolving inserted addresses as soon as they have
been added to an AV, even if asynchronous operation has been specified.
Similarly, a provider may lazily release resources from removed entries. 
.SH "RETURN VALUES"
Returns 0 on success.  On error, a negative value corresponding to
fabric errno is returned.
.PP
Fabric errno values are defined in
.IR "rdma/fi_errno.h".
.SH "ERRORS"
.SH "SEE ALSO"
fi_getinfo(3), fi_endpoint(3), fi_domain(3)
