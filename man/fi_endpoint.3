.TH "FI_ENDPOINT" 3 "2014-05-01" "libfabric" "Libfabric Programmer's Manual" libfabric
.SH NAME
fi_endpoint \- Fabric endpoint operations
.PP
fi_endpoint \ fi_pendpoint \ fi_close
.RS
Allocate or close an endpoint.
.RE
.PP
fi_ep_bind
.RS
Associate an endpoint with an event queue, address vector, or
memory region
.RE
.PP
fi_enable
.RS
Transitions an endpoint into an active state.
.RE
.PP
fi_cancel
.RS
Cancel a pending asynchronous data transfer
.RE
.PP
fi_alias
.RS
Create an alias to the endpoint
.RE
.PP
fi_ep_control
.RS
Control endpoint operation.
.RE
.PP
fi_getopt / fi_setopt
.RS
Get or set endpoint options.
.RE
.SH SYNOPSIS
.B "#include <rdma/fabric.h>"
.br
.B "#include <rdma/fi_endpoint.h>"
.HP
.BI "int fi_endpoint(struct fid_domain *" domain ", struct fi_info *" info ", "
.BI "struct fid_ep **" ep ", void *" context ");"
.HP
.BI "int fi_pendpoint(struct fi_fabric *" fabric ", struct fi_info *" info ", "
.BI "struct fid_pep **" pep ", void *" context ");"
.HP
.BI "int fi_close(struct fid_ep *" ep ");"
.PP
.HP
.BI "int fi_ep_bind(struct fid *" ep ", " fid_t " fid ", uint64_t " flags ");"
.PP
.HP
.BI "int fi_enable(struct fid_ep *" ep ");"
.PP
.HP
.BI "int fi_cancel(struct fid_ep *" ep ", void *" context ");"
.PP
.HP
.BI "int fi_ep_sync(struct fid_ep *" ep ", uint64_t " flags ", void *" context ");"
.PP
.HP
.BI "int fi_alias(struct fid_ep *" ep ", fid_t * " alias_ep ", uint64_t " flags ");"
.PP
.HP
.BI "int fi_ep_control(struct fid *" ep ", int " command ", void *" arg ");"
.PP
.HP
.BI "int fi_getopt(struct fid_ *" ep ", int " level ", int " optname ","
.BI "void *" optval ", size_t *" optlen ");"
.HP
.BI "int fi_setopt(struct fid *" ep ", int " level ", int " optname ","
.BI "const void *" optval ", size_t " optlen ");"
.SH ARGUMENTS
.IP "fid" 12
On creation, specifies a fabric or access domain.  On bind, identifies the
event queue or address vector to bind to the endpoint.
.IP "info" 12
Details about the fabric interface endpoint to be opened, obtained from
fi_getinfo.
.IP "ep" 12
A fabric endpoint.
.IP "fid" 12
Fabric identifier of an associated resource.
.IP "context" 12
Context associated with the endpoint or asynchronous operation.
.IP "flags" 12
Additional flags to apply to the operation.
.IP "command" 12
Command of control operation to perform on endpoint.
.IP "arg" 12
Optional control argument
.IP "level" 12
Protocol level at which the desired option resides.
.IP "optname" 12
The protocol option to read or set.
.IP "optval" 12
The option value that was read or to set.
.IP "optlen" 12
The size of the optval buffer.
.SH "DESCRIPTION"
Endpoints are transport level communication portals.  There are two types
of endpoints: active and passive.  Passive endpoints belong to a fabric
domain and are used to listen for incoming connection requests.  Active
endpoints belong to access domains and can perform data transfers.
.PP
Data transfer interfaces are bound to active endpoints.  Active endpoints
may be connection-oriented or connectionless, and may provide data
reliability.
.PP
Active endpoints are created in the disabled state.  They must transition into
an enabled state before being used to connect to a remote destination
or transfer data.  The fi_enable call is used to transition an endpoint into
an active state.
.PP
In order to transition an endpoint into an enabled state, it must be
bound to one or more fabric resources.  An endpoint that
will generate asynchronous events, either through data transfer operations
or communication establishment events, must be bound to the appropriate
event collectors before being enabled.
.PP
Once an endpoint has been activated, it may be associated with memory
regions and address vectors.  Receive buffers may be posted to it, and
calls may be made to connection establishment routines.
Connectionless endpoints may also perform data transfers. 
.PP
The behavior of an endpoint may be adjusted by setting its control
data and protocol options.  This allows the underlying provider to
redirect function calls to implementations optimized to meet the
desired application behavior.
.SS "fi_endpoint"
fi_endpoint allocates a new active endpoint.  The properties and behavior
of the endpoint are defined based on the provided struct fi_info.  See
fi_getinfo for additional details on fi_info.  fi_info flags that control
the operation of an endpoint are defined below.
.SS "fi_pendpoint"
Allocates a new passive endpoint with basic properties defined by struct
fi_info.
.SS "fi_close"
Closes an endpoint and release all resources associated with it.
.SS "fi_ep_bind"
fi_ep_bind is used to associate an endpoint with hardware resources.
The common use of fi_ep_bind is to direct asynchronous operations
associated with an endpoint to an event queue.  An endpoint must be
bound with ECs capable of reporting completions for any asynchronous
operation initiated on the endpoint.  For connection-oriented
endpoints, this requires binding the endpoint with an EC that supports
the communication management (CM) domain.
.PP
An active endpoint may direct asynchronous completions to different ECs, based
on the type of operation.  This is specified using fi_ep_bind flags.  The
following flags may be used separately or OR'ed together when binding
an endpoint to a completion domain EC.
.RS
.IP "FI_SEND"
Directs the completion of outbound data transfer requests to the
specified event queue.  This includes send message, RMA, and atomic
operations.
.IP "FI_RECV"  
Directs the notification of inbound data transfers to the
specified event queue.  This includes received messages.
.RE
.PP
Active endpoints that are configured to use index based addressing --
FI_ADDR_INDEX -- must be bound to a single AV.  AV binding can occur
before or after an endpoint has been enabled.
.SS "fi_enable"
This call transitions the endpoint into an enabled state.  An endpoint
must be enabled before it may be used to perform data transfers.
Enabling an endpoint typically results in hardware resources being
assigned to it.
.PP
Calling connect or accept on an endpoint will implicitly enable an
endpoint if it has not already been enabled. 
.SS "fi_cancel"
fi_cancel attempts to cancel an outstanding asynchronous operation.
The endpoint must have been configured to support cancelable operations --
see FI_CANCEL flag -- in order for this call to succeed.  Canceling
an operation causes the fabric provider to search for the operation
and, if it is still pending, complete it immediately as having been
canceled.
.SS "fi_ep_sync"
The sync function is used to indicate that all previously identified
operations have completed, with their results flushed from any intermediate
caches.  In this regard, it acts as a fencing operation.  When an fi_ep_sync
call completes, it indicates that all prior operations, as indicated by the
fi_ep_sync flags, submitted before fi_ep_sync call have also completed.
By default (flags are 0), fi_ep_sync completes only after all outbound
operations have completed.  This includes message sends, RMA reads and writes,
and atomic operations.
.PP
The behavior of fi_ep_sync may be adjusted by specifying one or more of the
following flags.
.IP "FI_READ"
The sync call will not complete until all outstanding RMA or atomic read
data transfers have completed.  The sync is not ordered with respect
to non-read operations.
.IP "FI_WRITE"
The sync call will not complete until all outstanding RMA or atomic write
data transfers have completed.  The sync is not ordered with respect to
non-write operations.
.IP "FI_SEND"
The sync call will not complete until all outstanding message send
data transfers have completed.  The sync is not ordered with respect to
non-send operations.
.IP "FI_REMOTE_WRITE"
The FI_REMOTE_WRITE flag is used in conjunction with access domains that
do NOT support FI_WRITE_COHERENT.  The fi_ep_sync with FI_REMOTE_WRITE is
issued on the target side of an RMA or atomic data transfer.  It ensures
that the view of memory of the local process is consistent with memory
updates from the network.  See fi_getinfo for additional details on
FI_WRITE_COHERENT.
.SS "fi_alias"
This call creates an alias to the specified endpoint.  Conceptually, an
endpoint alias provides an alternate software path from the
application to the underlying provider hardware.  Applications
configure an alias endpoint with data transfer flags, specified through
the fi_alias call.  Typically, the data transfer flags will be different
than those assigned to the actual endpoint.  The alias mechanism allows a
single endpoint to have multiple optimized software interfaces.  All
allocated aliases must be closed for the underlying endpoint to be
released.
.SS "fi_ep_control"
The control operation is used to adjust the default behavior of an
endpoint.  It allows the underlying provider to redirect function
calls to implementations optimized to meet the desired application
behavior.  As a result, calls to fi_ep_control must be serialized
against all other calls to an endpoint.
.PP
The base operation of an endpoint is selected during creation using
struct fi_info.  The following control commands and arguments may be
assigned to an endpoint.
.IP "FI_GETOPSFLAG -- uint64_t *flags"
Used to retrieve the current value of flags associated with data transfer
operations initiated on the endpoint.  See below for a list of control
flags.
.IP "FI_SETOPSFLAG -- uint64_t *flags"
Used to change the data transfer operation flags associated with an
endpoint.  The FI_READ, FI_WRITE, FI_SEND, FI_RECV flags indicate the
type of data transfer that the flags should apply to, with other flags
OR'ed in.  Valid control flags are defined below.
.SS "fi_getopt / fi_setopt"
Endpoint protocol operations may be retrieved using fi_getopt or set
using fi_setopt.  Applications specify the level that a desired option
exists, identify the option, and provide input/output buffers to
get or set the option.  fi_setopt provides an application a way to
adjust low-level protocol and implementation specific details of an
endpoint.
.PP
The following option levels and option names and parameters are defined.
.IP "FI_OPT_ENDPOINT"
.RS
.IP "FI_OPT_MAX_BUFFERED_SEND - size_t"
Defines the maximum buffered send operation (see the FI_BUFFERED_SEND
flag) that the endpoint currently supports.  This value applies per send
operation.
.IP "FI_OPT_TOTAL_BUFFERED_SEND - size_t"
Defines the total available space allocated to buffer send operations (see
the FI_BUFFERED_SEND flag) that the endpoint currently supports.
.IP "FI_OPT_TOTAL_BUFFERED_RECV - size_t"
Defines the total available space allocated to buffer received messages
(see the FI_BUFFERED_RECV flag) that the endpoint currently supports.
.IP "FI_OPT_MAX_MESSAGE_SIZE - size_t"
Defines the maximum size for an application data transfer as a
single operation.
.RE
.SH "CONTROL FLAGS"
The following flags may be set to control the operation of data transfers
initiated on an endpoint.  See fi_getinfo for additional descriptions of
the flags.
.IP "FI_BUFFERED_SEND"
Indicates that all outbound data buffer should be returned to the user's
control immediately after a data transfer call returns, even if the
operation is handled asynchronously.  This may require that the
provider copy the data into a local buffer and transfer out of that buffer.
A provider may limit the total amount of send data that may be buffered
and/or the size of a single send.  Applications may discover and modify these
limits using the endpoint's getopt and setopt interfaces.
.IP "FI_BUFFERED_RECV"
If set, the communication interface implementation should attempt to queue inbound
data that arrives before a receive buffer has been posted.  In the
absence of this flag, any messages that arrive before a receive is
posted are lost.
.IP "FI_EVENT"
Indicates that the endpoint should, by default, only generate completion
entries for data transfer operations that have the FI_EVENT flag set.
When set the user must determine when a request that does NOT have
FI_EVENT set has completed indirectly, usually based on the completion
of a subsequent operation.  Use of this flag may improve performance by
allowing the provider to avoid writing a completion entry for every operation.
.IP "FI_REMOTE_COMPLETE"
Indicates that local completions should not be generated
until the operation has completed on the remote side.
.IP "FI_CANCEL"
Indicates that the user wants the ability to cancel an operation posted
to the endpoint, if it does not complete first.
.IP "FI_READ"
Indicates that the user wants to initiate reads against remote memory
regions.  Remote reads include some RMA and atomic operations.
.IP "FI_WRITE"
Indicates that the user wants to initiate writes against remote memory
regions.  Remote writes include some RMA and most atomic operations.
.IP "FI_SEND"
Indicates that the endpoint will be used to send message data transfers.
Message transfers include base message operations as well as tagged message
functionality.
.IP "FI_RECV"
Indicates that the endpoint will be used to receive message data transfers.
Message transfers include base message operations as well as tagged message
functionality.
.IP "FI_REMOTE_READ"
Indicates that the endpoint should allow remote endpoints to read memory
regions exposed by this endpoint.  Remote read operations include some RMA
and atomic operations.
.IP "FI_REMOTE_WRITE"
Indicates that the endpoint should allow remote endpoints to write to memory
regions exposed by this endpoint.  Remote write operations include some RMA
operations and most atomic operations.
.SH "RETURN VALUE"
Returns 0 on success. On error, a negative value corresponding to fabric
errno is returned. Fabric errno values are defined in 
.IR "rdma/fi_errno.h".
.SH "NOTES"
Users should call fi_close to release all resources allocated to the fabric
endpoint.
.SH "RETURN VALUES"
Returns 0 on success.  On error, a negative value corresponding to
fabric errno is returned.
.PP
Fabric errno values are defined in
.IR "rdma/fi_errno.h".
.SH "ERRORS"
.IP "-FI_EDOMAIN"
A resource domain was not bound to the endpoint or an attempt was made to
bind multiple domains.
.IP "-FI_ENOEC"
The endpoint has not been configured with necessary event collectors.
.IP "-FI_EOPBADSTATE"
The endpoint's state does not permit the requested operation.
.SH "SEE ALSO"
fi_getinfo(3), fi_open(3), fi_domain(3), fi_msg(3), fi_tagged(3), fi_rma(3)
