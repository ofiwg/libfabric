.TH "FI_GETINFO" 3 "2014-07-25" "libfabric" "Libfabric Programmer's Manual" libfabric
.SH NAME
fi_getinfo / fi_freeinfo \- Obtain / free fabric interface information
.SH SYNOPSIS
.B "#include <rdma/fabric.h>"
.HP
.BI "int fi_getinfo(int " version ", const char *" node ", const char *" service ","
.BI "uint64_t " flags ", struct fi_info *" hints ", struct fi_info **" info ");"
.HP
.BI "int fi_freeinfo(struct fi_info *" info ");"
.SH ARGUMENTS
.IP "version"
Interface version requested by application.
.IP "node"
Optional, name or fabric address to resolve.
.IP "service"
Optional, service name or port number of address.
.IP "flags"
Operation flags for the fi_getinfo call.
.IP "hints"
Reference to an fi_info structure that specifies criteria for selecting
the returned fabric information.
.IP "info"
A pointer to a linked list of fi_info structures containing response
information.
.SH "DESCRIPTION"
Returns information about available fabric services for reaching the specified
node or service, subject to any provided hints.  Callers must provide at least
one of the node, service, or hints parameters.  If no matching fabric information
is available, info will be set to NULL.
.PP
The version parameter is used by the application to request the desired
version of the interfaces.  The version determines the format of all data
structures used by any of the fabric interfaces.  Applications should use the
FI_VERSION(major, minor) macro to indicate the version, with hard-coded integer
values for the major and minor values.  The FI_MAJOR_VERSION and FI_MINOR_VERSION
enum values defined in fabric.h specify the latest version of the installed
library.  However, it is recommended that the integer values for FI_MAJOR_VERSION
and FI_MINOR_VERSION be used, rather than referencing the enum types in order
to ensure compatibiliy with future versions of the library.  This protects
against the application being built from source against a newer version of the
library that introduces new fields to data structures, which would not be
initialized by the application.
.PP
Either node, service, or hints must be provided.  If hints are provided, the
operation will be controlled by hints.ai_flags.  If FI_PASSIVE is
specified, the call will resolve address information for use on the
passive side of a connection.
If node is provided, fi_getinfo will attempt to resolve the fabric address
to the given node.  The hints parameter, if provided,
may be used to control the resulting output as indicated below.
If node is not given, fi_getinfo will attempt to resolve the fabric addressing
information based on the provided hints.
.PP
The caller must call fi_freeinfo to release fi_info structures returned
by this call.
.SH "FI_INFO"
.nf
struct fi_info {
	struct fi_info     *next;
	size_t              size;
	uint64_t            type;
	uint64_t            protocol;
	uint64_t            ep_cap;
	uint64_t            op_flags;
	uint64_t            domain_cap;
	enum fi_addr_format addr_format;
	enum fi_addr_format info_addr_format;
	size_t              src_addrlen;
	size_t              dest_addrlen;
	void               *src_addr;
	void               *dest_addr;
	size_t              auth_keylen;
	void               *auth_key;
	struct fi_ep_attr  *ep_attr;
	uint64_t            msg_order;
	enum fi_threading   threading;
	enum fi_progress    control_progress;
	enum fi_progress    data_progress;
	char               *fabric_name;
	char               *domain_name;
	size_t              datalen;
	void               *data;
};
.fi
.IP "next"
Pointer to the next fi_info structure in the list.  Will be NULL
if no more structures exist.
.IP "size"
Size of the fi_info structure, used for compatibility.  Callers should specify
the size of any fi_info structure passed in as hints.  The size set on any fi_info
structures returned from fi_getinfo indicates the size that was interpreted by
the providers.
.IP "type"
If specified, indicates the type of fabric interface communication desired.
Supported types are listed in the
.B Socket types
section below.
.IP "protocol"
If specified, indicates the desired communication protocol. Supported protocols
are listed in the
.B "Protocols"
section below.
.IP "ep_cap"
If specified, indicates the desired endpoint communication capabilities. Supported
capabilities are listed in the
.B "Endpoint capabilities"
section below.
.IP "op_flags"
Flags that control the operation of endpoints and other objects opened
using the returned fi_info structure.  Supported op_flags are listed in the 
.B "Op flags"
section below.
.IP "domain_cap"
If specified, indicates the desired domain capabilities.  Supported capabilities
are listed in the
.B "Domain capabilities"
section below. 
.IP "addr_format"
If specified, indicates the format used for addressing in data transfer
operations. Supported formats
are listed in the
.B "Addressing formats"
section below.
.IP "info_addr_format"
If specified, indicates the format of addresses referenced by struct fi_info.
Supported formats are listed in the
.B "Addressing formats"
section below.
.IP "src_addrlen"
Indicates the length of the source address (must be specified if
.B src_addr
is specified).
.IP "dest_addrlen"
Indicates the length of the destination address (must be specified if
.B dst_addr
is specified).
.IP "src_addr"
If specified, indicates the source address.
.IP "dest_addr"
If specified, indicates the destination address.
.IP "auth_keylen"
Indicates the size of the authentication key (must be specified if
.B auth_key
is specified).
.IP "auth_key"
Authorization key to limit communication among endpoints that share
the same key.  Also defines permission for sharing resources with
other processes on the same node.
.IP "ep_attr"
Optionally supplied endpoint attributes.
.IP "msg_order"
Specifies the order in which the transport protocol processes headers.
.IP "threading"
This indicates the threading serialization model that the application and
provider will adhere to.  The treading model only applies to data transfer operations.
(See the data_progress field for details.)
.IP "control_progress"
This field indicates the method that the provider uses to make progress
on asynchronous control operations.  Control operations are function
which do not directly involve the transfer of application data between
endpoints.  They include address vector, memory registration, and
connection management routines.  See additional details below.
.IP "data_progress"
This field indicates the method that the provider uses to make progress on
data transfer operations.  This includes message queue, RMA, tagged messaging,
and atomic operations, along with their completion processing.
See below for additional details.
.IP "fabric_name"
If specified, the name of the fabric domain.
.IP "domain_name"
If specified, the name of the access domain.
.IP "datalen"
Length of any additional data (must be specified if
.B data
is specified).
.IP "data"
Any additional data about communication interface being requested.  Data is
provider specific.  It is primarily used as output from fi_getinfo, to be
provided as input into fi_domain or fi_endpoint.
.SH "ENDPOINT CAPABILITIES"
Endpoint capabilities are obtained by OR-ing the following flags together.
If endpoint capabilities in the hint parameter are set to 0, the underlying
provider will return the set of capabilities which are supported.  Otherwise,
providers will only return endpoints matching the specified set of
capabilities.
.IP "FI_PASSIVE"
Indicates that the fabric endpoint will be used to listen for connection
requests.  Use of this capability implies the use of the fi_getinfo flag
FI_SOURCE. 
.IP "FI_MSG"
Specifies that an endpoint should support sending and receiving
messages or datagrams.  Message capabilities imply support for send and/or
receive queues.  Endpoints supporting this capability support operations
defined by struct fi_ops_msg.
.sp
The ep_cap may be used to specify or restrict the type of messaging
operations that are supported.  In the absence of any relevant flags,
FI_MSG implies the ability to send and receive messages.
Applications can use the FI_SEND and FI_RECV flags to optimize an endpoint
as send-only or receive-only.
.IP "FI_RMA"
Specifies that the endpoint should support RMA read and write
operations.  Endpoints supporting this capability support operations
defined by struct fi_rma_ops.  In the absence of any relevant flags,
FI_RMA implies the ability to initiate and be the target of
remote memory reads and writes.  Applications can use the FI_READ, FI_WRITE,
FI_REMOTE_READ, and FI_REMOTE_WRITE flags to restrict the types of RMA
operations supported by an endpoint.
.IP "FI_TAGGED"
Specifies that the endpoint should handle tagged message transfers.
tagged message transfers associate a user-specified key or tag with each message
that is used for matching purposes at the remote side.  Endpoints supporting
this capability support operations defined by struct fi_tagged_ops.
In the absence of any relevant flags, FI_TAGGED implies the ability
to send and receive tagged messages.  Applications can use the FI_SEND and
FI_RECV flags to optimize an endpoint as send-only or receive-only.
.IP "FI_ATOMICS"
Specifies that the endpoint supports some set of atomic operations.
Endpoints supporting this capability support operations defined by struct
fi_atomic_ops.  In the absence of any relevant flags, FI_ATOMICS
implies the ability to initiate and be the target of
remote atomic reads and writes.  Applications can use the FI_READ, FI_WRITE,
FI_REMOTE_READ, and FI_REMOTE_WRITE flags to restrict the types of
atomic operations supported by an endpoint.
.IP "FI_MULTICAST"
Indicates that the endpoint should support multicast data transfers.
Endpoints supporting this capability support multicast operations defined by
struct fi_msg_ops, when a multicast address is specified as the destination
address.  In the absence of any relevant flags, FI_MULTICAST implies
the ability to send and receive messages.  Applications can use the FI_SEND and
FI_RECV flags to optimize an endpoint as send-only or receive-only.
.IP "FI_TRIGGER"
Indicates that the endpoint should support triggered operations.  Endpoints
support this capability must meet the usage model as described by
fi_trigger.3. 
.IP "FI_BUFFERED_RECV"
Requests that the communication endpoint should attempt to queue
inbound data that arrives before a receive buffer has been posted.  In the
absence of this flag, any messages that arrive before a receive is
posted are lost.  Applications may access endpoint options (getopt/setopt)
to determine the size of available buffered receive space.
.IP "FI_INJECT"
Indicates that the endpoint be able to support the FI_INJECT flag on
data transfer operations and the 'inject' data transfer calls.  The
minimum supported size of an inject operation that an endpoint 
with this capability must support is 8-bytes.  Applications may access
endpoint options (getopt/setopt) to determine injected transfer limits.
.IP "FI_MULTI_RECV"
Specifies that the endpoint must support the FI_MULTI_RECV flag when
posting receive buffers.
.IP "FI_READ"
Indicates that the user requires an endpoint capable of initiating reads
against remote memory regions.  Remote reads include some RMA and atomic
operations.
.IP "FI_WRITE"
Indicates that the user requires an endpoint capable of initiating writes
against remote memory regions.  Remote writes include some RMA and most
atomic operations.
.IP "FI_SEND"
Indicates that the user requires an endpoint capable of sending message data
transfers.  Message transfers include base message operations as well as
tagged message functionality.
.IP "FI_RECV"
Indicates that the user requires an endpoint capable of receiving message
data transfers.  Message transfers include base message operations as well
as tagged message functionality.
.IP "FI_REMOTE_READ"
Indicates that the user requires an endpoint capable of receiving read memory
operations from remote endpoints.  Remote read operations include some RMA
and atomic operations.
.IP "FI_REMOTE_WRITE"
Indicates that the user requires an endpoint capable of receiving write memory
operations from remote endpoints.  Remote write operations include some RMA
operations and most atomic operations.
.IP "FI_REMOTE_EQ_DATA"
Applications may include a small message with a data transfer that is
placed directly into a remote event queue as part of a completion event.
This is referred to as remote EQ data (sometimes referred to as immediate data).
The FI_REMOTE_EQ_DATA indicates that an endpoint must support the
FI_REMOTE_EQ_DATA flag on data transfer operations.  The minimum supported size
of remote EQ data that an endpoint with this capability must support
is 4-bytes.  Applications may access endpoint options (getopt/setopt)
to determine remote EQ data limits.
.IP "FI_REMOTE_SIGNAL"
Indicates that the endpoint support the FI_REMOTE_SIGNAL flag on
data transfer operations.  Support requires marking outbound data
transfers as signaled and handling incoming transfers appropriately. 
.IP "FI_REMOTE_COMPLETE"
Indicates that the endpoint support the FI_REMOTE_COMPLETE flag on
data transfer operations.  Support requires marking outbound data
transfers as using remote completions and responding to incoming transfers
appropriately.
.IP "FI_CANCEL"
Indicates that the user desires the ability to cancel outstanding data
transfer operations.  If FI_CANCEL is not set, a provider may optimize code
paths with the assumption that fi_cancel will not be used by the application.
.SH "OP FLAGS"
Operation flags are obtained by OR-ing the following flags together.
Operation flags define the default flags applied to an endpoint's data
transfer operations, where a flags parameter is not available.  Data transfer
operations that take flags as input override the op_flags value of an
endpoint.
.IP "FI_INJECT"
If set, all data buffers used with outbound transfers return to the user's
control immediately after the call returns.  This is true even if the
operation is handled asynchronously.  This may require that the communication
interface implementation copy the data into a local buffer or inject the data
directly into the outbound transfer queue.
.IP "FI_MULTI_RECV"
Applies to posted receive operations.  This flag allows the user to post a
single buffer that will receive multiple incoming messages.  Received
messages will be packed into the receive buffer until the buffer has been
consumed.  Use of this flag may cause a single posted receive operation
to generate multiple events as messages are placed into the buffer.
The placement of received data into the buffer may be subjected to
provider specific alignment restrictions.  The buffer will be freed from
the endpoint when a message is received that cannot fit into the remaining
free buffer space.
.IP "FI_EVENT"
Indicates that a completion entry should be generated for data transfer
operations.
.IP "FI_REMOTE_SIGNAL"
Indicates that a completion event at the target process should be generated
for the given operation.  The remote endpoint must be configured with
FI_REMOTE_SIGNAL, or this flag will be ignored by the target.  The local
endpoint must be configured with the FI_REMOTE_SIGNAL capability in order
to specify this flag.
.IP "FI_REMOTE_COMPLETE"
Indicates that a completion should not be generated for a data transfer
operation until the operation has completed on the remote side.  The remote
endpoint must be configured with FI_REMOTE_COMPLETE for correct operation.
The local endpoint must be configured with the FI_REMOTE_COMPLETE capability
in order to specify this flag.
.SH "ENDPOINT TYPES"
.IP "FID_UNSPEC"
The type of endpoint is not specified.  This is usually provided as input, with
other attributes of the endpoint or the provider selecting the type.
.IP "FID_MSG"
Provides a reliable, connection-oriented data transfer service with flow
control that maintains message boundaries.
.IP "FID_STREAM [not targeting 1.0 release]"
Provides reliable, byte streaming communication.
.IP "FID_DGRAM"
Supports a connectionless, unreliable datagram communication.  Message
boundaries are maintained, but the maximum message size may be limited to
the fabric MTU.  Flow control is not guaranteed.
.IP "FID_RAW [not targeting 1.0 release]"
Provides raw link-level network access.
.IP "FID_RDM"
Reliable datagram message.  Provides a reliable, unconnected data transfer
service with flow control that maintains message boundaries.
.IP "FID_PACKET [not targeting 1.0 release]"
Provides raw network-level access.
.SH "PROTOCOLS"
.IP "FI_PROTO_UNSPEC"
The protocol is not specified.  This is usually provided as input, with other
attributes of the socket or the provider selecting the actual protocol.
.IP "FI_PROTO_IB_RC"
The protocol runs over Infiniband reliable-connected queue pairs.
.IP "FI_PROTO_IWARP"
The protocol runs over the Internet wide area RDMA protocol transport.
.IP "FI_PROTO_IB_UC"
The protocol runs over Infiniband unreliable-connected queue pairs.
.IP "FI_PROTO_IB_UD"
The protocol runs over Infiniband unreliable datagram queue pairs.
.IP "FI_PROTO_IB_XRC [1.0 release TBD]"
The protocol runs over Infiniband extended reliable-connected queue pairs.
.IP "FI_PROTO_RAW [not targeting 1.0 release]"
Indicates that a raw link-layer or network-layer protocol is in use.
.SH "DOMAIN CAPABILITIES"
Domain capabilities are obtained by OR-ing the following flags together.
Domain capabilities are most often used as output information from fi_getinfo,
allowing applications to adjust their behavior based on the provider's
hardware or software abilities.  However,specific capabilities may be
requested through the hints parameter, with the actual supported capabilities
returned by the provider.  Applications must check domain capabilities to
ensure that all provider requirements for using resources associated with
the access domain are met.
.IP "FI_WRITE_COHERENT"
Specifies that remote writes, including atomic operations, to the underlying
access domain are coherent with the local processing domain.  Domain-level
write coherency indicates that changes to local memory are visible to the
local process immediately upon completion of a remote write operation.  The
absence of this flag allows the NIC or memory subsystem to cache the results
of remote write or atomic operations in non-coherent memory.
.sp
The behavior of a domain with and without FI_WRITE_COHERENT is illustrated
below.
.nf

      Process 1            Process 2
                           Register BUF
      RMA write X to BUF
      Notify process 2
                           Receive notification
                           if not FI_WRITE_COHERENT
                                Sync with remote writes
                           assert(BUF == X)

.fi
.sp
This flag may be set on input hints to fi_getinfo, with the provider clearing
the flag on output if it does not provide write coherency.  See the endpoint
fi_ep_sync call for handling non-coherent writes.
.IP "FI_CONTEXT"
Specifies that the provider requires that applications use struct fi_context
as their per operation context parameter.  This structure should be treated as
opaque to the application.  For performance reasons, this structure must be
allocated by the user, but may be used by the fabric provider to track the
operation.  Typically, users embed struct fi_context within their own
context structure.  The struct fi_context must remain valid until the
corresponding operation completes or is successfully canceled.  As such,
fi_context should NOT be allocated on the stack.  Doing so is likely to
result in stack corruption that will be difficult to debug.  Users should
not update or interpret the fields in this structure, or reuse it until
the original operation has completed.  The structure is
specified in rdma/fabric.h.
.IP "FI_LOCAL_MR"
The provider is optimized around having applications register memory
for locally accessed data buffers.  Data buffers used in send and receive
operations and as the source buffer for RMA and atomic operations must be
registered by the application for access domains opened with this capability.
.IP "FI_USER_MR_KEY"
The provider supports user requested memory registration keys.  Providers
that set this capability honor the requested_key parameter for memory
registration calls.
.IP "FI_DYNAMIC_MR"
The provider supports applications registering any range of addresses
in their virtual address space, whether or not those addresses are
back by physical pages or have been allocated to the app.
Providers that lack this capability require that registered memory
regions be backed by allocated memory pages.
.SH "ADDRESSING FORMATS"
Additional information on address formats is available under address vector
.BR "fi_av(3)".
.IP "FI_ADDR"
Address is of type void *.  Addresses of type FI_ADDR are returned when
inserting addresses into address vector maps.  An FI_ADDR points to a
opaque, provider specific mapping of a transport address, which can avoid
the need to translate higher-level addresses into provider specific addresses
needed for data transfer operations.
.IP "FI_ADDR_INDEX"
Address is a size_t index into an address vector.  Addresses of type
FI_ADDR_INDEX are returned when inserting addresses into address vector tables.
An FI_ADDR_INDEX is an index into an AV table, which can avoid
the need to translate higher-level addresses into provider specific addresses
needed for data transfer operations.
.IP "FI_ADDR_PROTO"
FI_ADDR_PROTO indicates that a protocol specific address format should be
used.  Protocol specific addresses are treated as opaque by applications,
and they target applications which make use of an out of band address exchange.
Applications which use FI_ADDR_PROTO may use fi_getname() to obtain the
protocol specific address assigned to an allocated endpoint.
.IP "FI_SOCKADDR"
Address if of type sockaddr.
.IP "FI_SOCKADDR_IN"
Address is of type sockaddr_in (IPv4).
.IP "FI_SOCKADDR_IN6"
Address is of type sockaddr_in6 (IPv6).
.IP "FI_SOCKADDR_IB"
Address is of type sockaddr_ib (defined in Linux kernel source 
.BR "include/rdma/ib.h").
.SH "Endpoint Attributes"
Endpoint attributes may be specified and returned as part of fi_getinfo.
When provided as hints, requested values of struct fi_ep_attr should be
set.  On output, the actual endpoint attributes
that can be provided will be returned.  Output values will be greater than
or equal to requested input values.
.nf
struct fi_ep_attr {
	int       data_flow_cnt;
	size_t    max_msg_size;
	size_t    inject_size;
	size_t    total_buffered_recv;
	size_t    max_order_raw_size;
	size_t    max_order_war_size;
	size_t    max_order_waw_size;
	uint64_t  max_tag_value;
};
.fi
.IP "Data Flow Count"
Specifies the number of independent data flows to associate with the endpoint.
A data flow conceptually represents independent hardware queues or paths
through the fabric.  Data flows may be mapped to different command queues
or fabric quality of service levels.  Data transfers may be associated with
a specific data flow as part of the operation.  If a data flow is not
specified, a data transfers will use the default flow associated with an
endpoint.  
.IP "Max Message Size"
Defines the maximum size for an application data transfer as a
single operation.
.IP "Inject Size"
Defines the default inject operation size (see the FI_INJECT
flag) that an endpoint will support.  This value applies per send
operation.
.IP "Total Buffered Receive"
Defines the total available space allocated by the provider to buffer received
messages (see the FI_BUFFERED_RECV flag).
.IP "Max RMA Ordered Size"
The maximum ordered size specifies the delivery order of transport data
into target memory for RMA and atomic operations.  Data ordering is separate,
but dependent on message ordering (defined below).  Data ordering
is unspecified where message order is not defined.
.sp
Data ordering refers to the access of target memory by subsequent operations.
When back to back RMA read or write operations access the same registered
memory location, data ordering indicates whether the second operation reads
or writes the target memory after the first operation has completed.  Because
RMA ordering applies between two operations, and not within a single data
transfer, ordering is defined per byte-addressable memory location.  I.e.
ordering specifies whether location X is accessed by the second operation
after the first operation.  Nothing is implied about the completion of the
first operation before the second operation is initiated. 
.sp
In order to support large data transfers being broken into multiple packets
and sent using multiple paths through the fabric, data ordering may be
limited to transfers of a specific size or less.  Providers specify when
data ordering is maintained through the following values.  Note that even
if data ordering is not maintained, message ordering may be.
.RS
.IP "max_order_raw_size"
Read after write size.  If set, an RMA or atomic read operation issued after
an RMA or atomic write operation, both of which are smaller than the size,
will be ordered.  The RMA or atomic read operation will see the results of
the previous RMA or atomic write.
.IP "max_order_war_size"
Write after read size.  If set, an RMA or atomic write operation issued after
an RMA or atomic read operation, both of which are smaller than the size,
will be ordered.  The RMA or atomic read operation will see the initial value
of the target memory region before a subsequent RMA or atomic write updates
the value.
.IP "max_order_waw_size"
Write after write size.  If set, an RMA or atomic write operation issued after
an RMA or atomic write operation, both of which are smaller than the size,
will be ordered.  The target memory region will reflect the results of the
second RMA or atomic write.
.RE
.sp
An order size value of 0 indicates that ordering is not guaranteed.  A value
of -1 guarantees ordering for any data size.
.IP "max_tag_value"
The maximum tag value is the largest application tag value supported by a
provider over an endpoint.  A provider will ignore any tag bits or values
larger than the max_tag_value.  This field only applies to endpoints that
support the tagged message interfaces.
.SH "Message Ordering"
Message ordering refers to the order in which transport layer headers (as
viewed by the application) are processed.  Relaxed message order enables
data transfers to be sent and received out of order, which may improve
performance by utilizing multiple paths through the fabric from the initiating
endpoint to a target endpoint.  Message order applies only between a single
source and destination endpoint pair.  Ordering between different target
endpoints is not defined.
.PP
Message order is determined using a set of ordering bits.  Each set bit
indicates that ordering is maintained between data transfers of the specified
type.  Message order is defined for [read | write | send] operations submitted
by an application after [read | write | send] operations.
.PP
Message ordering only applies to the processing of transport headers.  Message
ordering is necessary, but does not guarantee the order in which data is
sent or received by the transport layer.
.IP "FI_ORDER_RAR"
Read after read.  If set, RMA and atomic read operations are processed in the
order submitted relative to other RMA and atomic read operations.  If not
set, RMA and atomic reads may be processed out of order from their submission.
.IP "FI_ORDER_RAW"
Read after write.  If set, RMA and atomic read operations are processed in the
order submitted relative to RMA and atomic write operations.  If not
set, RMA and atomic reads may be processed ahead of RMA and atomic writes.
.IP "FI_ORDER_RAS"
Read after send.  If set, RMA and atomic read operations are processed in the
order submitted relative to message send operations, including tagged sends.
If not set, RMA and atomic reads may be processed ahead of sends.
.IP "FI_ORDER_WAR"
Write after read.  If set, RMA and atomic write operations are processed in the
order submitted relative to RMA and atomic read operations.  If not
set, RMA and atomic writes may be processed ahead of RMA and atomic reads.
.IP "FI_ORDER_WAW"
Write after write.  If set, RMA and atomic write operations are processed in the
order submitted relative to other RMA and atomic write operations.  If not
set, RMA and atomic writes may be processed out of order from their submission.
.IP "FI_ORDER_WAS"
Write after send.  If set, RMA and atomic write operations are processed in the
order submitted relative to message send operations, including tagged sends.
If not set, RMA and atomic writes may be processed ahead of sends.
.IP "FI_ORDER_SAR"
Send after read.  If set, message send operations, including tagged sends,
are processed in order submitted relative to RMA and atomic read operations.
If not set, message sends may be processed ahead of RMA and atomic reads.
.IP "FI_ORDER_SAW"
Send after write.  If set, message send operations, including tagged sends,
are processed in order submitted relative to RMA and atomic write operations.
If not set, message sends may be processed ahead of RMA and atomic writes.
.IP "FI_ORDER_SAS"
Send after send.  If set, message send operations, including tagged sends,
are processed in the order submitted relative to other message send.
If not set, message sends may be processed out of order from their submission.
.SH "THREAD SERIALIZATION"
The threading model specifies the level of serialization required of an
application when using the libfabric data transfer interfaces.  Control
interfaces are always considered thread safe, and may be accessed by
multiple threads.  Applications which can guarantee serialization in their
access of provider allocated resources and interfaces enables a provider
to eliminate lower-level locks.
.IP "FI_THREAD_UNSPEC"
This value indicates that no threading model has been defined.  It may be
used on input hints to the fi_getinfo call.
.IP "FI_THREAD_SAFE"
A thread safe serialization model allows a multi-threaded application to
access any allocated resources through any interface without restriction.
All providers are required to support FI_THREAD_SAFE.
.IP "FI_THREAD_PROGRESS"
A progress serialization model requires applications to serialize access
to provider resources and interfaces based on the progress model.  For
providers with automatic progress, access to each endpoint must be serialized,
and access to each event queue, counter, wait or poll set must be serialized.
Serialization is required only by threads accessing the same object.  For
example, one thread may be initiating a data transfer on an endpoint, while
another thread reads from an event queue associated with the endpoint.
Serialization to endpoint access is further limited to different endpoint
data flows, if available.  Multiple threads may initiate transfers on the
same endpoint if they reference different data flows.
.sp
For providers with manual progress, applications must serialize their access
to any object that is part of a single progress domain.  A progress domain
is any set of associated endpoints, event queues, counters, wait sets, and
poll sets.  For instance, endpoints that share the same event queue or poll
set belong to the same progress domain.  Applications that can allocate
endpoint resources to specific threads can reduce provider locking by
using FI_THREAD_PROGRESS.
.SH "PROGRESS"
Progress is the ability of the underlying implementation to complete
processing of an asynchronous request.  In many cases, the processing of
an asynchronous request requires the use of the host processor.  For example,
a received message may need to be matched with the correct buffer, or a timed
out request may need to be retransmitted.  For performance reasons, it may be
undesirable for the provider to allocate a thread for this purpose, which
will compete with the application threads.
.PP
To balance between performance and ease of use, two progress models are
defined.
.IP "FI_PROGRESS_UNSPEC"
This value indicates that no progress model has been defined.  It may be
used on input hints to the fi_getinfo call.
.IP "FI_PROGRESS_AUTO"
This progress model indicates that the provider will make forward progress
on an asynchronous operation without further intervention by the application.
When FI_PROGRESS_AUTO is provided as output to fi_getinfo in the absence of
any progress hints, it often indicates that the desired functionality is
implemented by the provider hardware or is a standard service of
the operating system.
.sp
All providers are required to support FI_PROGRESS_AUTO.  However, if a
provider does not natively support automatic progress, forcing the use of
FI_PROGRESS_AUTO may result in threads being allocated below the fabric
interfaces.
.IP "FI_PROGRESS_MANUAL"
This progress model indicates that the provider requires the use of an
application thread to complete an asynchronous request.  When manual
progress is set, the provider will attempt to advance an asynchronous
operation forward when the application invokes any event queue read or
wait operation where the completion will be reported.  Progress also
occurs when the application processes a poll or wait set.
.sp
Only wait operations defined by the fabric interface will result in an
operation progressing.  Operating system or external wait functions,
such as select, poll, or pthread routines, cannot.
.SH "FLAGS"
The operation of the fi_getinfo call may be controlled through the use of
input flags.  Valid flags include the following.
.IP "FI_NUMERICHOST"
Indicates that the node parameter is a numeric string representation of a
fabric address, such as a dotted decimal IP address.  Use of this flag will
suppress any lengthy name resolution protocol.
.IP "FI_SOURCE"
Indicates that the node and service parameters specify the local source
address to associate with an endpoint.
.SH "RETURN VALUE"
Returns 0 on success. On error, a negative value corresponding to fabric
errno is returned. Fabric errno values are defined in 
.IR "rdma/fi_errno.h".
.SH "ERRORS"
.IP "FI_EBADFLAGS"
The specified endpoint or domain capability or operation flags are invalid. 
.IP "FI_ENOMEM"
Indicates that there was insufficient memory to complete the operation.
.IP "FI_ENODATA"
Indicates that no providers could be found which support the requested
fabric information.
.IP "FI_ENOSYS"
No fabric providers were found.
.SH "NOTES"
If hints are provided, the
operation will be controlled by the values that are supplied in the various
fields (see section on
.IR "fi_info").
Applications that require specific communication interfaces, domains,
capabilities or other requirements, can specify them using fields in
.IR "hints".
Libfabric returns a linked list in
.I info
that points to a list of matching interfaces.  
.I info 
is set to NULL if there are no communication interfaces or none match
the input hints.
.PP
If node is provided, fi_getinfo will attempt to resolve the fabric address
to the given node.  If node is not provided, fi_getinfo will attempt to resolve
the fabric addressing information based on the provided hints.  The caller must
call fi_freeinfo to release fi_info structures returned by fi_getinfo.
.PP
If neither node, service or hints are provided, then fi_getinfo simply returns
the list all available communication interfaces.
.PP
Multiple threads may call 
.BR fi_getinfo " simultaneously, without any requirement for serialization."
.SH "SEE ALSO"
fi_open(3), fi_domain(3), fi_endpoint(3)
