.\" Automatically generated by Pandoc 1.19.2.4
.\"
.TH "fi_rxm" "7" "2018\-11\-12" "Libfabric Programmer\[aq]s Manual" "\@VERSION\@"
.hy
.SH NAME
.PP
fi_rxm \- The RxM (RDM over MSG) Utility Provider
.SH OVERVIEW
.PP
The RxM provider (ofi_rxm) is an utility provider that supports
FI_EP_RDM type endpoint emulated over FI_EP_MSG type endpoint(s) of an
underlying core provider.
FI_EP_RDM endpoints have a reliable unconnected messaging interface and
RxM emulates this by hiding the connection management of underlying
FI_EP_MSG endpoints from the user.
Additionally, RxM can hide memory registration requirement from a core
provider like verbs if the apps don\[aq]t support it.
.SH REQUIREMENTS
.SS Requirements for core provider
.PP
RxM provider requires the core provider to support the following
features:
.IP \[bu] 2
MSG endpoints (FI_EP_MSG)
.IP \[bu] 2
RMA read/write (FI_RMA) \- Used for implementing rendezvous protocol for
large messages.
.IP \[bu] 2
FI_OPT_CM_DATA_SIZE of at least 48 bytes
.SS Requirements for applications
.PP
Since RxM emulates RDM endpoints by hiding connection management and
connections are established only on\-demand (when app tries to send
data), the first several data transfer calls would return EAGAIN.
Applications should be aware of this and retry until the operation
succeeds.
.PP
If an application has chosen manual progress for data progress, it
should also read the CQ so that the connection establishment progresses.
Not doing so would result in a stall.
See also the ERRORS section in fi_msg(3).
.SH SUPPORTED FEATURES
.PP
The RxM provider currently supports \f[I]FI_MSG\f[], \f[I]FI_TAGGED\f[]
and \f[I]FI_RMA\f[] capabilities.
.TP
.B \f[I]Endpoint types\f[]
The provider supports only \f[I]FI_EP_RDM\f[].
.RS
.RE
.TP
.B \f[I]Endpoint capabilities\f[]
The following data transfer interface is supported: \f[I]FI_MSG\f[],
\f[I]FI_TAGGED\f[], \f[I]FI_RMA\f[].
.RS
.RE
.TP
.B \f[I]Progress\f[]
The RxM provider supports both \f[I]FI_PROGRESS_MANUAL\f[] and
\f[I]FI_PROGRESS_AUTO\f[].
The former is more optimal.
.RS
.RE
.TP
.B \f[I]Addressing Formats\f[]
FI_SOCKADDR, FI_SOCKADDR_IN
.RS
.RE
.TP
.B \f[I]Memory Region\f[]
FI_MR_VIRT_ADDR, FI_MR_ALLOCATED, FI_MR_PROV_KEY MR mode bits would be
required from the app in case the core provider requires it.
.RS
.RE
.SH LIMITATIONS
.PP
When using RxM provider, some limitations from the underlying MSG
provider could also show up.
Please refer to the corresponding MSG provider man pages to find about
those limitations.
.SS Unsupported features
.PP
RxM provider does not support the following features:
.IP \[bu] 2
op_flags: FI_FENCE.
.IP \[bu] 2
FI_ATOMIC
.IP \[bu] 2
Scalable endpoints
.IP \[bu] 2
Shared contexts
.IP \[bu] 2
FABRIC_DIRECT
.IP \[bu] 2
FI_MR_SCALABLE
.IP \[bu] 2
Authorization keys
.IP \[bu] 2
Application error data buffers
.IP \[bu] 2
Multicast
.IP \[bu] 2
FI_ADDR_STR, FI_SYNC_ERR
.IP \[bu] 2
Reporting unknown source addr data as part of completions
.IP \[bu] 2
Triggered operations
.SS Progress limitations
.PP
When sending large messages, an app doing an sread or waiting on the CQ
file descriptor may not get a completion when reading the CQ after being
woken up from the wait.
The app has to do sread or wait on the file descriptor again.
This is needed because RxM uses a rendezvous protocol for large message
sends.
An app would get woken up from waiting on CQ fd when rendezvous protocol
request completes but it would have to wait again to get an ACK from the
receiver indicating completion of large message transfer by remote RMA
read.
.SH RUNTIME PARAMETERS
.PP
The ofi_rxm provider checks for the following environment variables.
.TP
.B \f[I]FI_OFI_RXM_BUFFER_SIZE\f[]
Defines the transmit buffer size / inject size.
Messages of size less than this would be transmitted via an eager
protocol and those above would be transmitted via a rendezvous or SAR
(Segmentation And Reassembly) protocol.
Transmit data would be copied up to this size (default: ~16k).
.RS
.RE
.TP
.B \f[I]FI_OFI_RXM_COMP_PER_PROGRESS\f[]
Defines the maximum number of MSG provider CQ entries (default: 1) that
would be read per progress (RxM CQ read).
.RS
.RE
.TP
.B \f[I]FI_OFI_RXM_SAR_LIMIT\f[]
Set this environment variable to control the RxM SAR (Segmentation And
Reassembly) protocol.
Messages of size greater than this (default: 256 Kb) would be
transmitted via rendezvous protocol.
.RS
.RE
.TP
.B \f[I]FI_OFI_RXM_USE_SRX\f[]
Set this to 1 to use shared receive context from MSG provider.
This reduces overall memory usage but there may be a slight increase in
latency (default: 0).
.RS
.RE
.TP
.B \f[I]FI_OFI_RXM_TX_SIZE\f[]
Defines default TX context size (default: 1024)
.RS
.RE
.TP
.B \f[I]FI_OFI_RXM_RX_SIZE\f[]
Defines default RX context size (default: 1024)
.RS
.RE
.TP
.B \f[I]FI_OFI_RXM_MSG_TX_SIZE\f[]
Defines FI_EP_MSG TX size that would be requested (default: 128).
.RS
.RE
.TP
.B \f[I]FI_OFI_RXM_MSG_RX_SIZE\f[]
Defines FI_EP_MSG RX size that would be requested (default: 128).
.RS
.RE
.TP
.B \f[I]FI_UNIVERSE_SIZE\f[]
Defines the expected number of ranks / peers an endpoint would
communicate with (default: 256).
.RS
.RE
.SH Tuning
.SS Bandwidth
.PP
To optimize for bandwidth, ensure you use higher values than default for
FI_OFI_RXM_TX_SIZE, FI_OFI_RXM_RX_SIZE, FI_OFI_RXM_MSG_TX_SIZE,
FI_OFI_RXM_MSG_RX_SIZE subject to memory limits of the system and the tx
and rx sizes supported by the MSG provider.
.PP
FI_OFI_RXM_SAR_LIMIT is another knob that can be experimented with to
optimze for bandwidth.
.SS Memory
.PP
To conserve memory, ensure FI_UNIVERSE_SIZE set to what is required.
Similarly check that FI_OFI_RXM_TX_SIZE, FI_OFI_RXM_RX_SIZE,
FI_OFI_RXM_MSG_TX_SIZE and FI_OFI_RXM_MSG_RX_SIZE env variables are set
to only required values.
.SH SEE ALSO
.PP
\f[C]fabric\f[](7), \f[C]fi_provider\f[](7), \f[C]fi_getinfo\f[](3)
.SH AUTHORS
OpenFabrics.
